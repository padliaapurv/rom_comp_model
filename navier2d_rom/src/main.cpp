#include <iostream>
#include <Eigen/Dense>
#include <fstream>
#include "Config.h"
#include "OfflineSolver2D.h"
#include "POD.h"
#include "GalerkinROM.h"
#include "OnlineSolver2D.h"

// Helper function: load snapshot matrix from a text file.
// The first line of the file must contain two integers: n (rows) and m (columns),
// followed by n*m double values.
Eigen::MatrixXd loadSnapshotMatrix(const std::string& file) {
    std::ifstream ifs(file);
    if (!ifs.is_open()) {
        throw std::runtime_error("Cannot open snapshot file: " + file);
    }
    int n, m;
    ifs >> n >> m;  // Read matrix dimensions.
    Eigen::MatrixXd X(n, m);
    for (int row = 0; row < n; ++row) {
        for (int col = 0; col < m; ++col) {
            double val;
            ifs >> val;
            X(row, col) = val;
        }
    }
    return X;
}

int main() {
    try {
        // 1. Read configuration from config.txt.
        // The config.txt file is expected to be in the parent directory of the build folder.
        Config cfg = Config::fromTXT("../config.txt");

        std::cout << "[main] Loaded configuration:\n";
        std::cout << "  Grid: " << cfg.Nx << " x " << cfg.Ny << ", Domain: " 
                  << cfg.Lx << " x " << cfg.Ly << "\n";
        std::cout << "  Time: dt = " << cfg.dt << ", finalTime = " << cfg.finalTime << "\n";
        std::cout << "  Viscosity: " << cfg.viscosity << "\n";
        std::cout << "  Snapshot Interval: " << cfg.snapshotInterval << "\n";
        std::cout << "  Snapshot File: " << cfg.snapshotFile << "\n";
        std::cout << "  Number of POD Modes: " << cfg.numPodModes << "\n";

        // 2. Run the full offline solver (simulate PDE and save snapshots).
        std::cout << "[main] Running offline PDE solver...\n";
        OfflineSolver2D offline(cfg);
        offline.runOfflineSolve();
        std::cout << "[main] Offline PDE solve completed.\n";

        // 3. Load the snapshot matrix generated by the offline solver.
        Eigen::MatrixXd X = loadSnapshotMatrix(cfg.snapshotFile);
        std::cout << "[main] Loaded snapshot matrix with dimensions: " 
                  << X.rows() << " x " << X.cols() << "\n";

        // 4. Compute the POD basis from the snapshot matrix.
        POD pod(cfg.numPodModes);
        pod.computeBasis(X);
        std::cout << "[main] POD basis computed.\n";

        // 5. Build the Galerkin ROM using the POD basis.
        double dx = cfg.Lx / (cfg.Nx - 1);
        double dy = cfg.Ly / (cfg.Ny - 1);
        GalerkinROM gal(pod, cfg.Nx, cfg.Ny, dx, dy, cfg.viscosity);
        std::cout << "[main] Galerkin ROM constructed.\n";

        // 6. Select an initial condition for the online (reduced) simulation.
        // Here, we take the first column from the snapshot matrix.
        Eigen::VectorXd x0 = X.col(0);
        std::cout << "[main] Initial condition loaded from snapshot.\n";

        // 7. Run the online reduced-order simulation.
        OnlineSolver2D online(cfg, gal);
        Eigen::VectorXd xFinalROM = online.runReducedSolve(x0);
        std::cout << "[main] Online reduced simulation completed.\n";

        // 8. For comparison, get the final offline snapshot (last column).
        Eigen::VectorXd xFinalOffline = X.col(X.cols() - 1);

        // 9. Compute the error between the offline and ROM solutions.
        double errorNorm = (xFinalOffline - xFinalROM).norm();
        double refNorm = xFinalOffline.norm();
        double relativeError = errorNorm / (refNorm + 1e-14);

        std::cout << "[main] Offline final solution norm: " << refNorm << "\n";
        std::cout << "[main] ROM final solution norm: " << xFinalROM.norm() << "\n";
        std::cout << "[main] Relative error: " << relativeError << "\n";

        return 0;
    } catch (const std::exception &ex) {
        std::cerr << "[main] Exception: " << ex.what() << "\n";
        return 1;
    }
}
